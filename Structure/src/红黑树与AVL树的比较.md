红黑树和AVL树都是从二叉搜索树进化而来的平衡二叉树。
## AVL树的特点

1. 一个节点的左右子数的高度差不大于1
2. 一个节点的左右子数都是平衡二叉树
3. 平衡二叉树满足二叉树所有的特点

##AVL树的时间复杂度

1. 一颗n个结点的AVL树的平均搜索复杂度是O(logn)
2. 一颗n个结点的AVL树删除一个结点做平衡旋转的时间复杂度是O(logn)
3. 一颗n个结点的AVL树插入一个结点做平衡旋转的时间复杂度是O(logn)

**插入操作**:AVL树在插入一个结点时，这个树上的个节点都有可能改变平衡状态。在平衡调整的过程中，我们需要调整其中平衡状态被改变最深的那个结点就可以保证该节点以上的路径能保持平衡，平衡调整主要通过左旋，右旋来调整的。所以插入操作需要O(logn)的遍历时间以及至多两次旋转的时间。

**删除操作**：AVL树在删除一个结点时候，沿着被删除的结点自下而上的调整实际删除结点的父节点到根节点之间的子数的平衡状态。和插入操作不同的是，删除操作不只需要调整最深的不平衡子数，而且需要不断上溯判断是否也需要调整，直到根节点。所以AVL树的删除操作需要若干次旋转才能恢复平衡。

**查找操作**：和二分查找的思想大体相同，如果查找的数比当前结点小，那么就在当前结点的左边查找，以此类推，所以平均的时间复杂度是O(logn),但是也不排除在二叉树中插入的序列是有序的，数的结构趋向一条线，这种查找的时间复杂度就会和链表的时间复杂度相近为O(n),如下如中的（b）图，这也是为什么在二叉搜索树的基础上又出现了AVL树。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021600255176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6aDEwOQ==,size_16,color_FFFFFF,t_70)

# 红黑树

红黑树和AVL树一样都是从二叉搜索树上演变而来，也是自平衡的二叉搜索树。它没有AVL树那样对调整的要求那么高，降低了对调整（旋转）的要求，从而提高了性能。红黑树的从根节点到叶子节点的最长路径不会超过最短路径的两倍，所以说红黑树是相对接近平衡二叉树的。
红黑树的特性

1. 每个结点或者为黑或者是红色，只有这两种颜色，不会有其他的颜色
2.    红黑树的根节点一定是黑色的
3.    红色的结点的子节点一定是黑色结点
 4.   所有的叶子结点一定是黑色的
5.    每一条从根节点到叶子结点的路径上的黑色结点是相等的
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216002602377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6aDEwOQ==,size_16,color_FFFFFF,t_70)

红黑树的时间复杂度

**查找操作：**查找操作红黑树和AVL树和搜索二叉树一样，都是二分查找的思想，所以说是O(logn)

**插入操作：**插入操作我们需要先插入的位置，插入之后可能破坏树的平衡，所以需要调整，红黑树的任何不平衡都会在三次旋转之类解决（插入最多需要两次），所以也是O(logn)

**删除操作：**删除操作我们需要先插入的位置，插入之后可能破坏树的平衡，所以需要调整，红黑树的任何不平衡都会在三次旋转之类解决（删除最多需要3次），所以也是O(logn)
## 红黑树的应用

在我们经常用到的C++STL中的map,set,muiltmap等底层都是红黑树来实现的，还有libevent的epoll的底层也是红黑树
## 红黑树和AVL树各自的优点是什么？
    
 1.  如果插入一个结点引起了树的不平衡，AVL树和红黑树都最多2次旋转就可以使其平衡；在删除一个结点引起树的不平衡，最坏情况下，AVL树要从最深的不平衡结点来调整到这条路径上的所有结点的平衡性，因此需要若干次的旋转，而红黑树最多需要三次；
2.    AVL树是高度平衡的二叉搜索树，所以AVL的查找速率更快一点，红黑树的茶渣速率会稍微比AVL树慢一点，因为它没有AVL树那样的高度平衡，它比AVL树稍微不平衡多一层，所以查找的时候最多会多一次的比较
3.    AVL树在大量数据的插入和删除时，AVL树调整的次数会比红黑树调整的次数多，所以红黑树在插入和删除的大量结点的场景下效率会更高

